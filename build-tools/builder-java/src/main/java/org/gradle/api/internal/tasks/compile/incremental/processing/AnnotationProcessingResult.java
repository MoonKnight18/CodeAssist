package org.gradle.api.internal.tasks.compile.incremental.processing;

import org.gradle.api.internal.tasks.compile.incremental.compilerapi.deps.GeneratedResource;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Contains all the data necessary to make annotation processing incremental.
 */
public class AnnotationProcessingResult implements Serializable {

    private final Map<String, Set<String>> generatedTypesByOrigin = new LinkedHashMap<>();
    private final Map<String, Set<GeneratedResource>> generatedResourcesByOrigin = new LinkedHashMap<>();
    private final Set<String> aggregatedTypes = new HashSet<>();
    private final Set<String> generatedTypesDependingOnAllOthers = new HashSet<>();
    private final Set<GeneratedResource> getGeneratedResourcesDependingOnAllOthers = new HashSet<>();
    private final List<AnnotationProcessorResult> annotationProcessorResults = new ArrayList<>();
    private String fullRebuildCause;

    public void addGeneratedType(String name, Set<String> originatingElements) {
        for (String originatingElement : originatingElements) {
            Set<String> derived = generatedTypesByOrigin.get(originatingElement);
            if (derived == null) {
                derived = new LinkedHashSet<>();
                generatedTypesByOrigin.put(originatingElement, derived);
            }
            derived.add(name);
        }
    }

    public void addGeneratedResource(GeneratedResource resource, Set<String> originatingElements) {
        for (String originatingElement : originatingElements) {
            Set<GeneratedResource> derived = generatedResourcesByOrigin.get(originatingElement);
            if (derived == null) {
                derived = new LinkedHashSet<>();
                generatedResourcesByOrigin.put(originatingElement, derived);
            }
            derived.add(resource);
        }
    }

    /**
     * Contains the types generated by isolating annotation processors, grouped by the type they were generated from.
     */
    public Map<String, Set<String>> getGeneratedTypesWithIsolatedOrigin() {
        return generatedTypesByOrigin;
    }

    /**
     * Contains the resources generated by isolating annotation processors, grouped by the type they were generated from.
     */
    public Map<String, Set<GeneratedResource>> getGeneratedResourcesWithIsolatedOrigin() {
        return generatedResourcesByOrigin;
    }

    /**
     * Contains the types that aggregating annotation processors registered themselves for.
     * These types need to be reprocessed no matter what source changes are made to ensure that the generated types contain all relevant information.
     */
    public Set<String> getAggregatedTypes() {
        return aggregatedTypes;
    }

    /**
     * Contains the types that aggregating annotation processors generated.
     * These types need to be recompiled on any source change, because it may not be clear where these types came from and whether they are now stale.
     */
    public Set<String> getGeneratedAggregatingTypes() {
        return generatedTypesDependingOnAllOthers;
    }

    /**
     * Contains the resources that aggregating annotation processors generated.
     * These resources need to be recreated on any source change, because it may not be clear where these resources came from and whether they are now stale.
     */
    public Set<GeneratedResource> getGeneratedAggregatingResources() {
        return getGeneratedResourcesDependingOnAllOthers;
    }

    public void setFullRebuildCause(String fullRebuildCause) {
        this.fullRebuildCause = fullRebuildCause;
    }

    public String getFullRebuildCause() {
        return fullRebuildCause;
    }

    public List<AnnotationProcessorResult> getAnnotationProcessorResults() {
        return annotationProcessorResults;
    }
}

